"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fetch = require("jest-fetch-mock");
jest.setMock("node-fetch", fetch);
const requests_1 = require("../../src/utils/requests");
describe("request.ts", () => {
    let expectedHeader;
    let expectedBody;
    let expectedStatusCode;
    let expectedStatusText;
    beforeEach(() => {
        fetch.resetMocks();
        expectedHeader = { test: "header", new: "newHeader" };
        expectedBody = { test: "testBody" };
        expectedStatusCode = 200;
        expectedStatusText = "OK";
    });
    it("should call fetch with minimal valid data passed into request()", async () => {
        // Arrange
        fetch.mockResponseOnce(JSON.stringify(expectedBody));
        const resource = "http://localhost:3000/posts";
        const method = "GET";
        // Act
        await requests_1.request(method, resource);
        // Assert
        expect(fetch).toBeCalled();
    });
    it("should return a response with the correct header ", async () => {
        // Arrange
        const expectedResponse = {
            headers: {
                new: ["newHeader"],
                test: ["header"]
            },
            parsedBody: expectedBody,
            size: 0,
            statusCode: 404,
            statusText: "Not Found",
            timeout: 0
        };
        fetch.mockResponseOnce(JSON.stringify(expectedBody), {
            headers: expectedHeader,
            status: 404
        });
        const resource = "http://localhost:3000/posts";
        const method = "GET";
        // Act
        const actualResponse = await requests_1.request(method, resource);
        // Assert
        expect(actualResponse).toMatchObject(expectedResponse);
    });
    it("should return a response when the third party api error ", async () => {
        // Arrange
        const expectedResponse = {
            headers: {},
            parsedBody: expectedBody,
            size: 0,
            statusCode: 404,
            statusText: "Not Found",
            timeout: 0
        };
        fetch.mockResponseOnce(JSON.stringify(expectedBody), { status: 404 });
        const resource = "http://localhost:3000/posts";
        const method = "GET";
        // Act
        const actualResponse = await requests_1.request(method, resource);
        // Assert
        expect(actualResponse).toMatchObject(expectedResponse);
    });
    it("should error when fetch is called unsuccessfully", async () => {
        // Arrange
        const error = new Error("error");
        const expectedError = new Error(`ERROR on request: ${error.message}`);
        fetch.mockReject(error);
        const resource = "http://localhost:3000/posts";
        const method = "GET";
        // Act
        try {
            await requests_1.request(method, resource);
        }
        catch (err) {
            // Assert
            expect(err).toEqual(expectedError);
        }
    });
    it("should return a response with valid and optional data passed into request()", async () => {
        // Arrange
        fetch.mockResponseOnce(JSON.stringify(expectedBody));
        const expectedResponse = {
            headers: {},
            parsedBody: expectedBody,
            size: 0,
            statusCode: expectedStatusCode,
            statusText: expectedStatusText,
            timeout: 0
        };
        const resource = "http://localhost:3000/posts";
        const method = "POST";
        // Act
        const actualResponse = await requests_1.request(method, resource, expectedHeader, expectedBody);
        // Assert
        expect(actualResponse).toMatchObject(expectedResponse);
    });
    it("should return a response with valid data and have body null response from fetch", async () => {
        // Arrange
        fetch.mockResponseOnce(null);
        const resource = "http://localhost:3000/posts";
        const method = "POST";
        const expectedResponse = {
            headers: {},
            parsedBody: null,
            size: 0,
            statusCode: expectedStatusCode,
            statusText: expectedStatusText,
            timeout: 0
        };
        // Act
        const actualResponse = await requests_1.request(method, resource, expectedHeader, expectedBody);
        // Assert
        expect(actualResponse).toMatchObject(expectedResponse);
    });
});
//# sourceMappingURL=requests.test.js.map