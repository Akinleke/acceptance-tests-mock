jest.mock('util');
jest.mock('child_process');

const util = require('util');
const child_process = require('child_process');
const script = require('../src/script');

const oriPromisify = util.promisify;
const oriEnv = process.env;

const logSpy = jest.spyOn(console, "log");
const errSpy = jest.spyOn(console, "error");

const promSpy = jest.spyOn(util, "promisify");

const mockPromisify = jest.fn().mockReturnValue(
			new Promise((resolve, reject) => {
				resolve("Default resolve");
			})
);

describe('Increasing npm version and pushing changes', () => {
	beforeEach(() => {
		jest.resetModules();
		jest.clearAllMocks();

		process.env = {...oriEnv};

		process.env.CI_PROJECT_PATH = "project/path";

		promSpy.mockReturnValue(mockPromisify);
	});

	it('Should resolve and execute two commands', done => {
		script.increaseVersion("Fake version")
		.then(response => {
			// Validate return value
			expect(response).toEqual("Done");

			// Validate function calls
			expect(mockPromisify.mock.calls.length).toBe(2);

			expect(logSpy).toHaveBeenCalledTimes(0);
			expect(errSpy).toHaveBeenCalledTimes(0);

			// All validation passed
			done();
		})
		.catch (err => {
			done.fail(`Unexpected error ${err}`);
		})
	})

	it('Should reject if the version command fails', done => {
		// Set return values for mock
		mockPromisify.mockReturnValueOnce(
			new Promise((resolve, reject) => {
				reject("Fake version");
			})
		);

		script.increaseVersion("Failing version")
		.then(response => {
			done.fail("Unexpected success");
		})
		.catch(err => {
			// Validate return value
			expect(mockPromisify.mock.calls.length).toBe(1);
			
			// Validate function calls
			expect(logSpy).toHaveBeenCalledTimes(0);
			expect(errSpy).toHaveBeenCalledTimes(1);

			expect(errSpy).toHaveBeenCalledWith("Failed to change version");

			// All validation passed
			done();
		})
	});

	it('Should reject if the push command fails', done => {
		// Set return values for mock
		mockPromisify.mockReturnValueOnce(
			new Promise((resolve, reject) => {
				resolve("Fake version");
			})
		);

		mockPromisify.mockReturnValueOnce(
			new Promise((resolve, reject) => {
				reject("Fake push");
			})
		);


		script.increaseVersion("Failing version")
		.then(response => {
			done.fail("Unexpected success ", response);
		})
		.catch(err => {
			// Validate return value
			expect(mockPromisify.mock.calls.length).toBe(2);

			// Validate function calls
			expect(logSpy).toHaveBeenCalledTimes(0);
			expect(errSpy).toHaveBeenCalledTimes(0);

			// All validation passed
			done();
		})
	});
});
